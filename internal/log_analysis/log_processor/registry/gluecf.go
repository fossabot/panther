package registry

// CloudFormation generation for Glue tables from parser event struct

import (
	"bytes"
	"fmt"
	"os"
	"reflect"
	"strings"

	"github.com/panther-labs/panther/internal/log_analysis/log_processor/parsers/timestamp"
	"github.com/panther-labs/panther/tools/cfngen"
	"github.com/panther-labs/panther/tools/cfngen/gluecf"
)

const (
	LogS3Prefix                 = "logs"
	InternalDatabaseName        = "panther_internal"
	InternalDatabaseDescription = "Holds tables generated by Panther data processing"

	glueTimestampType = "timestamp" // type in Glue tables for timestamps that we will re-map Go times
)

var (
	CatalogIDRef = cfngen.Ref{Ref: "AWS::AccountId"} // macro expand to accountId for CF

	// Glue mappings for timestamps.
	glueMappings = []gluecf.CustomMapping{
		{
			From: reflect.TypeOf(timestamp.RFC3339{}),
			To:   glueTimestampType,
		},
		{
			From: reflect.TypeOf(timestamp.ANSICwithTZ{}),
			To:   glueTimestampType,
		},
	}
)

// Re-map characters not allow in CF names consistently
func cfResourceClean(name string) string {
	return strings.Replace(name, "_", "", -1) // CF resources must be alphanum
}

// Use this to tag the time partitioning used in a Glue table
type GlueTableTimebin int

const (
	GlueTableMonthly GlueTableTimebin = iota + 1
	GlueTableDaily
	GlueTableHourly
)

func (tb GlueTableTimebin) Validate() (err error) {
	switch tb {
	case GlueTableHourly, GlueTableDaily, GlueTableMonthly:
		return
	default:
		err = fmt.Errorf("unknown Glue table time bin: %d", tb)
	}
	return
}

func (tb GlueTableTimebin) PartitionKeys() (keys []gluecf.Column) {
	switch tb {
	case GlueTableHourly:
		keys = []gluecf.Column{
			{Name: "year", Type: "int", Comment: "year"},
			{Name: "month", Type: "int", Comment: "month"},
			{Name: "day", Type: "int", Comment: "day"},
			{Name: "hour", Type: "int", Comment: "hour"},
		}
	case GlueTableDaily:
		keys = []gluecf.Column{
			{Name: "year", Type: "int", Comment: "year"},
			{Name: "month", Type: "int", Comment: "month"},
			{Name: "day", Type: "int", Comment: "day"},
		}
	case GlueTableMonthly:
		keys = []gluecf.Column{
			{Name: "year", Type: "int", Comment: "year"},
			{Name: "month", Type: "int", Comment: "month"},
		}
	}

	return
}

// Meta data about Glue table over parser data written to S3
// NOTE: this struct has all accessor behind functions to allow a lazy evaluation
//       so the cost of creating the schema is only when actually needing this information.
type GlueMetadata struct {
	databaseName string
	tableName    string
	s3Prefix     string           // where we expect to find data relative to the bucket
	timebin      GlueTableTimebin // at what time resolution is this table partitioned
	eventStruct  interface{}      // object used to infer columns
}

func (gm *GlueMetadata) DatabaseName() string {
	return gm.databaseName
}

func (gm *GlueMetadata) TableName() string {
	return gm.tableName
}

func (gm *GlueMetadata) S3Prefix() string {
	return gm.s3Prefix
}

func (gm *GlueMetadata) Timebin() GlueTableTimebin {
	return gm.timebin
}

func (gm *GlueMetadata) EventStruct() interface{} {
	return gm.eventStruct
}

func (gm *GlueMetadata) PartitionKeys() []gluecf.Column {
	return gm.timebin.PartitionKeys()
}

func (gm *GlueMetadata) Columns() []gluecf.Column {
	return gluecf.InferJSONColumns(gm.eventStruct, glueMappings...)
}

func NewGlueMetadata(databaseName, tableName string, timebin GlueTableTimebin, eventStruct interface{}) (gm *GlueMetadata, err error) {
	err = timebin.Validate()
	if err != nil {
		return
	}

	// clean table name to make sql friendly
	tableName = strings.Replace(tableName, ".", "_", -1) // no '.'
	tableName = strings.ToLower(tableName)

	gm = &GlueMetadata{
		databaseName: databaseName,
		tableName:    tableName,
		s3Prefix:     LogS3Prefix + "/" + tableName,
		timebin:      timebin,
		eventStruct:  eventStruct,
	}

	return
}

func generateGlueCloudFormation(reg Registry) (cf []byte, err error) {
	const bucketParam = "ProcessedDataBucket"
	parameters := make(map[string]interface{})
	parameters[bucketParam] = &cfngen.Parameter{
		Type:        "String",
		Description: "Bucket to hold data for tables",
	}

	// all tables are in one database
	db := gluecf.NewDatabase(CatalogIDRef, InternalDatabaseName, InternalDatabaseDescription)
	resources := map[string]interface{}{
		cfResourceClean(InternalDatabaseName): db,
	}

	// add tables for all parsers
	for _, p := range reg {
		location := cfngen.Sub{Sub: "s3://${" + bucketParam + "}/" + p.Glue.S3Prefix()}

		// NOTE: current all sources are JSONL (could add a type to LogParserMetadata struct if we need more types)
		table := gluecf.NewJSONLTable(&gluecf.NewTableInput{
			CatalogID:     CatalogIDRef,
			DatabaseName:  cfngen.Ref{Ref: cfResourceClean(InternalDatabaseName)},
			Name:          p.Glue.TableName(),
			Description:   p.Description,
			Location:      location,
			Columns:       p.Glue.Columns(),
			PartitionKeys: p.Glue.PartitionKeys(),
		})

		tableResource := cfResourceClean(p.Glue.DatabaseName() + p.Glue.TableName())
		resources[tableResource] = table
	}

	// generate CF using cfngen
	cfTemplate := cfngen.NewTemplate("Panther Glue Resources", parameters, resources)
	buffer := bytes.Buffer{}
	err = cfTemplate.WriteCloudFormation(&buffer)
	return buffer.Bytes(), err
}

// Generate cloud formation for gluecf ... call this during build
func GenerateGlueCloudFormation(glueCfFileName string) (err error) {
	// open file in local dir
	glueCfFile, err := os.Create(glueCfFileName)
	if err != nil {
		return
	}
	defer func() {
		glueCfFile.Close()
	}()

	cf, err := generateGlueCloudFormation(AvailableParsers())
	if err != nil {
		return
	}
	_, err = glueCfFile.Write(cf)
	return
}
